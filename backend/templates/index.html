<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>工作流创作与回顾 (最终功能版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
        html, body {
            height: 100%; /* 关键：让 html 和 body 占满全高 */
            margin: 0;
            overflow: hidden; /* 关键：禁止整个页面滚动 */
        }
        .node-card {
            width: 140px;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            border: 2px solid #e5e7eb;
            transition: border-color 0.2s;
        }
        .node-card.selected {
            border-color: #3b82f6;
        }
        .thumb {
            width: 140px;
            height: 100px;
            object-fit: cover;
            background: #f3f4f6;
            display: block;
        }
        .node-label {
            padding: 6px 8px;
            font-size: 12px;
            color: #111827;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .link {
            fill: none;
            stroke: #9ca3af;
            stroke-width: 2px;
        }
        .overlay {
            position: fixed;
            left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal {
            background: #fff;
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            padding: 12px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.4);
            overflow: auto;
        }
        .modal img, .modal video {
            max-width: 100%;
            max-height: 80vh;
            display: block;
            margin: 0 auto;
        }
        .clip-item {
            position: relative;
            cursor: grab;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px;
            background: white;
            transition: transform 0.2s;
        }
        .clip-item img, .clip-item video { /* 统一用img显示缩略图，简化 */
            width: 100px;
            height: 60px;
            object-fit: cover;
            display: block;
        }
        .clip-item .remove-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background: rgba(239, 68, 68, 0.8); /* Red-500 with opacity */
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border: 1px solid white;
        }
        .clip-item.dragging { /* 拖拽时的样式 */
            opacity: 0.5;
            transform: scale(1.05);
        }
        .drag-over { /* 拖放目标区域的样式 */
            border-style: solid;
            border-color: #3b82f6; /* Blue-500 */
        }
        /* 覆盖掉 .clip-item 的固定宽度 */
        .clip-item {
            position: relative;
            cursor: grab;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px;
            background: white;
            transition: transform 0.2s;
            /* 【新增】取消固定宽度，允许 JS 控制 */
            /* width: 100px; */
            flex-shrink: 0; /* 防止项目在 flex 布局中被压缩 */
        }

        /* 【新增】修改 clips-container 为水平滚动 */
        #clips-container {
            display: flex;
            flex-wrap: nowrap; /* 关键：不换行 */
            gap: 8px;
            overflow-x: auto;  /* 关键：允许水平滚动 */
            padding-bottom: 8px; /* 为滚动条留出空间 */
        }

        
        .loader { border-top-color: #3498db; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 h-screen flex flex-col">
    <div class="container mx-auto p-4 h-full flex flex-col">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-semibold text-gray-800">工作流创作与回顾</h1>
            <p id="status" class="text-gray-500 mt-1">正在从数据库加载作品...</p>
        </header>

        <main class="grid grid-cols-3 gap-6 flex-1 min-h-0">
            <div class="col-span-2 flex flex-col gep-4 min-h-0">
                <div id="chart-wrapper" class="bg-white rounded shadow p-3 flex-1 min-h-0" style="position: relative;">
                    <div id="chart" style="width:100%; height:100%;"></div>
                </div>

                <div class="bg-white rounded shadow p-4">
                    <h2 class="text-l font-semibold mb-4 text-gray-700">视频拼接序列</h2>
                    <div id="stitching-panel" class="bg-gray-100 p-4 rounded border border-dashed border-gray-300 min-h-[100px]">
                        <div id="clips-container" class="flex flex-wrap gap-3">
                            <span id="clips-placeholder" class="text-gray-500 italic">从上方历史树中添加视频片段到此区域...</span>
                        </div>
                    </div>
                    <button id="stitch-button" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-400">
                        拼接视频
                    </button>
                    <div id="stitch-result" class="mt-3 text-center"></div>
                </div>

            </div>

            <div class="col-span-1 overflow-y-auto">
                <div class="bg-white rounded shadow p-6">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700">工作流参数</h2>
                    <div id="workflow-form" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-600 mb-1">父节点</label>
                            <input id="selected-node-input" type="text" value="未选择 (将创建根节点)" class="w-full bg-gray-100 border border-gray-300 rounded-md p-2 text-gray-500 text-sm" readonly>
                        </div>
                        <div>
                            <label for="module-select" class="block text-sm font-medium text-gray-600 mb-1">选择模块</label>
                            <select id="module-select" class="w-full bg-white border border-gray-300 rounded-md p-2">
                                <option value="TextGenerateImage">TextToImage</option>
                                <option value="ImageGenerateImage_Basic">ImageToImage</option>
                                <option value="TextGenerateVideo">TextToVideo</option>
                                <option value="ImageGenerateVideo">ImageToVideo</option>
                                <option value="ImageMerging">ImageMerging</option>
                                <option value="ImageCanny">ImageCanny</option>
                                <option value="ImageGenerateImage_Canny">CannyToImage</option>
                            </select>
                        </div>
                        <div>
                            <label for="prompt-input" class="block text-sm font-medium text-gray-600 mb-1">Prompt</label>
                            <textarea id="prompt-input" rows="4" class="w-full bg-white border border-gray-300 rounded-md p-2" placeholder="请输入您的创意..."></textarea>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div><label for="seed-input" class="block text-sm font-medium text-gray-600 mb-1">Seed</label><input type="number" id="seed-input" class="w-full bg-white border border-gray-300 rounded-md p-2" placeholder="随机"></div>
                            <div><label for="steps-input" class="block text-sm font-medium text-gray-600 mb-1">Steps</label><input type="number" id="steps-input" class="w-full bg-white border border-gray-300 rounded-md p-2" value="20"></div>
                            <div><label for="cfg-input" class="block text-sm font-medium text-gray-600 mb-1">CFG</label><input type="number" id="cfg-input" step="0.1" class="w-full bg-white border border-gray-300 rounded-md p-2" value="7.5"></div>
                            <div><label for="denoise-input" class="block text-sm font-medium text-gray-600 mb-1">Denoise</label><input type="number" id="denoise-input" step="0.05" class="w-full bg-white border border-gray-300 rounded-md p-2" value="0.8"></div>
                        </div>
                        <div>
                            <label for="image-upload" class="block text-sm font-medium text-gray-600 mb-1">图片输入 (可选)</label>
                            <input type="file" id="image-upload" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-100 file:text-blue-700 hover:file:bg-blue-200">
                            <p class="text-xs text-gray-500 mt-1">提示：上传新图将覆盖父节点图像。</p>
                        </div>
                        <div class="pt-2">
                            <button id="generate-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center transition-colors disabled:bg-gray-400">
                                <span id="button-text">开始生成</span>
                                <div id="button-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 ml-3 hidden"></div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        

    </div>

    <div id="preview-overlay" style="display:none;"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const DB_API_GET_URL = '/api/trees/1';
    const DB_API_POST_URL = '/api/nodes';
    const ASSET_UPLOAD_URL = '/api/assets/upload';
    const COMFYUI_URL = 'http://223.193.6.178:8188';

    const statusEl = document.getElementById('status');
    const wrapper = document.getElementById('chart');
    const overlay = document.getElementById('preview-overlay');
    // 右侧面板的元素引用
    const selectedNodeInput = document.getElementById('selected-node-input');
    const moduleSelect = document.getElementById('module-select');
    const promptInput = document.getElementById('prompt-input');
    const generateBtn = document.getElementById('generate-btn');
    const imageUpload = document.getElementById('image-upload');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');

    //视频拼接
    const clipsContainer = document.getElementById('clips-container');
    const clipsPlaceholder = document.getElementById('clips-placeholder');
    const stitchButton = document.getElementById('stitch-button');
    const stitchResult = document.getElementById('stitch-result');

    let stitchingClips = []; // 存储待拼接的片段信息 { nodeId, mediaPath, thumbnailUrl }
    let draggedClipIndex = null; // 用于拖拽



    let selectedParentIds = [];
    let rootNodeId = null;
    let allNodes = [];

    
    function showStatus(text) { statusEl.textContent = text; }
    function parseAssetsField(assetsField) { if (!assetsField) return null; try { if (typeof assetsField === 'string') { if (assetsField.trim() === '' || assetsField.trim() === '{}') return null; return JSON.parse(assetsField); } else if (typeof assetsField === 'object') { return assetsField; } } catch (err) { console.warn('解析 assets 失败:', err, assetsField); return null; } return null; }
    function firstMediaFromAssets(assets) { if (!assets) return null; const imgs = assets.images || []; const vids = assets.videos || []; if (Array.isArray(imgs) && imgs.length > 0) return { path: imgs[0], type: 'image' }; if (Array.isArray(vids) && vids.length > 0) return { path: vids[0], type: 'video' }; return null; }
    function makeFullUrl(path) { if (!path) return null; if (path.startsWith('http://') || path.startsWith('https://')) return path; const cleanPath = path.startsWith('/') ? path : '/' + path; return COMFYUI_URL + cleanPath; }
    function openPreview(mediaUrl, type) { overlay.innerHTML = ''; overlay.style.display = 'flex'; overlay.className = 'overlay'; const modal = document.createElement('div'); modal.className = 'modal'; const closeBtn = document.createElement('div'); closeBtn.style.textAlign = 'right'; closeBtn.innerHTML = '<button class="px-3 py-1 bg-gray-200 rounded">关闭</button>'; closeBtn.querySelector('button').addEventListener('click', closePreview); modal.appendChild(closeBtn); if (type === 'video') { const v = document.createElement('video'); v.src = mediaUrl; v.controls = true; v.autoplay = true; modal.appendChild(v); } else { const img = document.createElement('img'); img.src = mediaUrl; img.alt = 'preview'; modal.appendChild(img); } overlay.appendChild(modal); overlay.addEventListener('click', (e) => { if (e.target === overlay) closePreview(); }); }
    function closePreview() { overlay.style.display = 'none'; overlay.innerHTML = ''; }
    function updateSelectedNodeInput() {
    if (selectedParentIds.length === 0) {
        selectedNodeInput.value = '未选择 (将创建根节点)';
    } else if (selectedParentIds.length === 1) {
        selectedNodeInput.value = `已选择 (1): ${selectedParentIds[0].substring(0, 8)}...`;
    } else {
        // 专为 ImageMerging 优化提示
        if (moduleSelect.value === 'ImageMerging' && selectedParentIds.length === 2) {
             selectedNodeInput.value = `已选择 2 个节点 (合并就绪)`;
        } else {
             selectedNodeInput.value = `已选择 (${selectedParentIds.length}) 个节点`;
        }
    }
}



    // --- 【新增】处理文件上传并创建 Upload 节点的函数 ---
    async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // 显示加载状态 (可以使用按钮的加载状态，或者独立的上传状态提示)
        statusEl.textContent = '正在上传图片并创建节点...';
        // 禁用上传按钮和生成按钮，防止并发操作
        imageUpload.disabled = true;
        generateBtn.disabled = true;

        const formData = new FormData();
        formData.append('file', file);

        // 构造带查询参数的URL
        let parentIdQuery = '';
        let currentParentId = (selectedParentIds.length > 0 ? selectedParentIds[selectedParentIds.length - 1] : null) || rootNodeId || null; // 优先使用选中的(最后一个)，否则用根，否则null
        if (currentParentId) {
            parentIdQuery = `&parent_id=${currentParentId}`;
        }
        const uploadUrl = `${ASSET_UPLOAD_URL}?tree_id=${1}${parentIdQuery}`;

        try {
            const response = await fetch(uploadUrl, { method: 'POST', body: formData });
            if (!response.ok) { const errText = await response.text(); throw new Error(`上传失败: ${errText}`); }

            const updatedTree = await response.json(); // 后端返回更新后的树
            processAndRenderTree(updatedTree, '上传成功！新节点已添加到历史树。'); // 使用新函数处理数据和渲染

            // 找到新添加的 Upload 节点并自动选中它
            const newUploadNode = findLatestUploadNode(updatedTree.nodes);
            if (newUploadNode) {
                selectedParentNodeId = newUploadNode.node_id;
                selectedNodeInput.value = `已选择: ${newUploadNode.node_id.substring(0, 8)}... (上传)`;
                // 下次 renderTree 时会自动高亮
            }

        } catch (error) {
            console.error("处理上传失败:", error);
            alert(`上传失败: ${error.message}`);
            statusEl.textContent = '上传失败，请重试。';
        } finally {
            // 恢复按钮状态
            imageUpload.disabled = false;
            generateBtn.disabled = false;
            imageUpload.value = ''; // 清空文件选择
        }
    }

    // 添加片段到拼接列表 (增加 isVideo 标记)
    // 【修改】添加片段到拼接列表 (变为 async 来获取视频时长)
    async function addClipToStitch(nodeData, type) {
        if (!nodeData.media || !nodeData.media.rawPath) return;
        if (stitchingClips.some(clip => clip.nodeId === nodeData.id)) {
            alert('该片段已在拼接序列中。');
            return;
        }

        try {
            if (type === 'video') {
                // 1. 对于视频，我们需要异步获取总时长
                const videoDuration = await getVideoDuration(nodeData.media.url); // 使用 media.url
                stitchingClips.push({
                    nodeId: nodeData.id,
                    mediaPath: nodeData.media.rawPath,
                    thumbnailUrl: nodeData.media.url,
                    type: 'video',
                    startTime: 0,
                    endTime: videoDuration,
                    totalDuration: videoDuration // 存储总时长用于验证
                });
            } else {
                // 2. 对于图片，我们只设置一个默认时长
                stitchingClips.push({
                    nodeId: nodeData.id,
                    mediaPath: nodeData.media.rawPath,
                    thumbnailUrl: nodeData.media.url,
                    type: 'image',
                    duration: 3.0 // 默认 3 秒
                });
            }

            renderStitchingPanel(); // 异步操作完成后再渲染

        } catch (error) {
            console.error("添加片段时出错:", error);
            alert("无法加载视频元数据，添加失败。");
        }
    }

    // 【新增】辅助函数：用于异步获取视频时长
    function getVideoDuration(videoUrl) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.onloadedmetadata = () => {
                resolve(video.duration);
            };
            video.onerror = (e) => {
                reject(new Error("视频元数据加载失败"));
            };
            video.src = videoUrl;
        });
    }


    // 移除片段
    function removeClipFromStitch(index) {
        stitchingClips.splice(index, 1);
        renderStitchingPanel();
    }

// 【修改】渲染拼接面板UI (增加时长和裁剪输入框)
    function renderStitchingPanel() {
        clipsContainer.innerHTML = '';
        if (stitchingClips.length === 0) {
            clipsPlaceholder.style.display = 'block';
            stitchButton.disabled = true;
        } else {
            clipsPlaceholder.style.display = 'none';
            stitchButton.disabled = false;
            stitchingClips.forEach((clip, index) => {
                const item = document.createElement('div');
                item.className = 'clip-item';
                item.draggable = true;
                item.dataset.index = index;

                // --- 【新增】根据时长计算宽度 ---
                const PIXELS_PER_SECOND = 20; // 每秒钟 20 像素
                let clipDuration;
                if (clip.type === 'video') {
                    clipDuration = clip.endTime - clip.startTime;
                } else {
                    clipDuration = clip.duration;
                }
                item.style.width = `${Math.max(50, clipDuration * PIXELS_PER_SECOND)}px`; // 最小 50px 宽
                // --- 结束新增 ---

                // --- 媒体元素 (与原来相同) ---
                let mediaElement;
                if (clip.type === 'video') {
                    mediaElement = document.createElement('video');
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                    mediaElement.muted = true;
                    mediaElement.playsInline = true;
                    mediaElement.preload = 'metadata';
                } else {
                    mediaElement = document.createElement('img');
                }
                mediaElement.src = clip.thumbnailUrl;
                mediaElement.className = 'thumb'; //
                item.appendChild(mediaElement);

                // --- 移除按钮 (与原来相同) ---
                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '×';
                removeBtn.onclick = (e) => { e.stopPropagation(); removeClipFromStitch(index); };
                item.appendChild(removeBtn);

                // --- 【新增】时长/裁剪输入框 ---
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'clip-controls';
                controlsDiv.style.padding = '4px';
                controlsDiv.style.fontSize = '10px';
                controlsDiv.style.background = '#f9f9f9';

                if (clip.type === 'image') {
                    // 图片：显示 "时长"
                    controlsDiv.innerHTML = `
                        <label>时长: <input type="number" value="${clip.duration.toFixed(1)}" step="0.1" min="0.1" class="w-full" data-index="${index}" data-field="duration"></label>
                    `;
                } else {
                    // 视频：显示 "开始" 和 "结束"
                    controlsDiv.innerHTML = `
                        <label>开始: <input type="number" value="${clip.startTime.toFixed(2)}" step="0.1" min="0" max="${clip.totalDuration}" class="w-full" data-index="${index}" data-field="startTime"></label>
                        <label>结束: <input type="number" value="${clip.endTime.toFixed(2)}" step="0.1" min="0" max="${clip.totalDuration}" class="w-full" data-index="${index}" data-field="endTime"></label>
                    `;
                }
                item.appendChild(controlsDiv);
                // --- 拖拽事件 (与原来相同) ---
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);

                clipsContainer.appendChild(item);
            });

            // 【新增】为所有新输入框添加事件监听
            clipsContainer.querySelectorAll('.clip-controls input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    let value = parseFloat(e.target.value);
                    const clip = stitchingClips[index];

                    if (isNaN(value) || value < 0) value = 0;

                    // 基本的验证
                    if (field === 'startTime') {
                        if (value >= clip.endTime) value = clip.endTime - 0.1;
                    }
                    if (field === 'endTime') {
                        if (value <= clip.startTime) value = clip.startTime + 0.1;
                        if (value > clip.totalDuration) value = clip.totalDuration;
                    }
                    if (field === 'duration') {
                         if (value < 0.1) value = 0.1;
                    }

                    // 更新数据源
                    clip[field] = value;
                    // 更新输入框的值 (防止无效输入)
                    e.target.value = value.toFixed(field === 'duration' ? 1 : 2);
                });
                // 阻止输入框的拖拽事件冒泡
                input.addEventListener('mousedown', e => e.stopPropagation());
            });
        }
    }

    // 拖拽处理函数 (加固逻辑)
    function handleDragStart(e) {
        // 确保设置数据，某些浏览器可能需要
        e.dataTransfer.setData('text/plain', this.dataset.index);
        e.dataTransfer.effectAllowed = 'move';
        draggedClipIndex = parseInt(this.dataset.index);
        // 使用 setTimeout 延迟添加 dragging 类，避免影响拖拽图像
        setTimeout(() => this.classList.add('dragging'), 0);
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        this.classList.add('drag-over');
    }

    function handleDragLeave(e) {
        this.classList.remove('drag-over');
    }

    function handleDrop(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        // 从事件数据中获取拖拽源索引（更可靠）
        // const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
        // 如果上面获取不到，再用全局变量 (兼容性)
        const sourceIndex = (draggedClipIndex !== null) ? draggedClipIndex : parseInt(e.dataTransfer.getData('text/plain'));
        const targetIndex = parseInt(this.dataset.index);

        if (isNaN(sourceIndex) || isNaN(targetIndex) || sourceIndex === targetIndex) {
             console.warn("拖拽索引无效或目标与源相同");
             // 确保清理 draggedClipIndex
             draggedClipIndex = null;
             // 强制移除 dragging 样式，以防万一
             document.querySelectorAll('.clip-item.dragging').forEach(el => el.classList.remove('dragging'));
             return;
        }

        // 重新排序数组
        const itemToMove = stitchingClips.splice(sourceIndex, 1)[0];
        if (itemToMove) {
             stitchingClips.splice(targetIndex, 0, itemToMove);
        } else {
             console.error("未能找到要移动的片段");
        }

        // 重置拖拽索引并重新渲染
        draggedClipIndex = null;
        renderStitchingPanel();
    }

    function handleDragEnd(e) {
        // 使用 try...finally 确保样式被移除
        try {
            // 清理所有 dragging 和 drag-over 样式
            document.querySelectorAll('.clip-item.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.clip-item.drag-over').forEach(el => el.classList.remove('drag-over'));
        } finally {
            draggedClipIndex = null; // 确保重置
        }
    }


    // --- 【修改】触发后端拼接的函数 (发送更丰富的数据) ---
    async function handleStitchRequest() {
        if (stitchingClips.length < 1) {
            alert('请至少添加一个片段进行拼接。');
            return;
        }
        stitchButton.disabled = true; stitchButton.textContent = '正在拼接...'; stitchResult.textContent = '';
        // 【修改】发送包含裁剪和时长的数据
        const clipsData = stitchingClips.map(clip => {
            if (clip.type === 'image') {
                return {
                    path: clip.mediaPath,
                    type: clip.type,
                    duration: clip.duration
                };
            } else { // 'video'
                return {
                    path: clip.mediaPath,
                    type: clip.type,
                    startTime: clip.startTime,
                    endTime: clip.endTime
                };
            }
        });

        try {
            const response = await fetch('/api/stitch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ clips: clipsData }) // <-- 发送新的 clips 数组
            });
            if (!response.ok) { const errText = await response.text(); throw new Error(`拼接失败: ${errText}`); }
            const result = await response.json();
            if (result.output_url) { stitchResult.innerHTML = `拼接完成！<a href="${result.output_url}" target="_blank" class="text-blue-500 hover:underline ml-2">点击下载/预览</a>;` }
            else { throw new Error('后端未返回有效的输出URL'); }
        } catch (error) { console.error(error); stitchResult.textContent = `错误: ${error.message}`; alert(error.message); }
        finally { stitchButton.disabled = false; stitchButton.textContent = '拼接视频'; }
    }

    // // 此函数现在将图片发送给我们自己的后端 app.py
    // async function uploadImage(file) {
    //     const formData = new FormData();
    //     formData.append('file', file);

    //     try {
            
    //         const response = await fetch('/api/assets/upload', {
    //             method: 'POST',
    //             body: formData
    //         });

    //         if (!response.ok) {
    //             const errText = await response.text();
    //             throw new Error(`上传请求失败: ${errText}`);
    //         }
    //         return await response.json();
    //     } catch (error) {
    //         console.error("上传图片失败的真实原因:", error);
    //         alert('上传图片失败! (请检查控制台以获取详细错误)');
    //         return null;
    //     }
    // }



    // --- 【修改】删除节点的函数 ---
    async function handleDeleteNode(nodeId, moduleId) {
        // 1. 关键：向用户确认
        const confirmMsg = `您确定要删除这个节点 (${moduleId || '节点'}) 吗？\n\n警告：这也会从数据库中删除所有依赖此节点的子孙节点！`;
        if (!confirm(confirmMsg)) {
            return;
        }

        // 2. 显示加载状态
        showStatus(`正在删除节点 ${nodeId.substring(0, 8)}...`);
        generateBtn.disabled = true;
        imageUpload.disabled = true;

        try {
            // 3. 定义 API URL
            const DELETE_API_URL = '/api/nodes';
            // 4. 发起 DELETE 请求
            const response = await fetch(`${DELETE_API_URL}/${nodeId}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`删除失败 (HTTP ${response.status}): ${errText}`);
            }

            // 5. 【修改】后端删除成功。现在我们清理前端。
            // 6. 检查已删除的节点是否是当前选中的父节点
            const indexInSelection = selectedParentIds.indexOf(nodeId);
            if (indexInSelection > -1) {                selectedParentIds.splice(indexInSelection, 1);
            }
            updateSelectedNodeInput(); // 更新文本框

            // 7. 【核心修复】不再使用 response.json()，
            //    而是直接调用 loadAndRender() 来重新加载整个树。
            await loadAndRender(); // <--- 这会重新获取并绘制树
            showStatus('节点删除成功。'); // 在 loadAndRender 之后显示成功

        } catch (error) {
            console.error("删除节点时出错:", error);
            alert(`删除失败: ${error.message}`);
            showStatus('删除失败，请重试。');
        } finally {
            // 8. 恢复按钮
            generateBtn.disabled = false;
            imageUpload.disabled = false;
        }
    }




    async function handleGenerate() {
        generateBtn.disabled = true;
        buttonText.textContent = '生成中...';
        buttonLoader.classList.remove('hidden');
        imageUpload.disabled = true; // 生成时也禁用上传

        try {
            //let parentId = selectedParentNodeId;
            let parentIds = [...selectedParentIds];
            //let parentIds = [];

            if (parentIds.length === 0) { // 未选择父节点
                if (allNodes.length > 0) { parentIds.push(rootNodeId) }
            }

            // if (parentId) { parentIds.push(parentId); }

            const moduleId = moduleSelect.value;
            const parameters = { positive_prompt: promptInput.value };
            const seed = document.getElementById('seed-input').value;
            parameters.seed = seed ? parseInt(seed) : Math.floor(Math.random() * 1000000000000000);
            ['steps', 'cfg', 'denoise'].forEach(id => {
                const el = document.getElementById(`${id}-input`);
                if (el && el.value) { parameters[id] = (id === 'cfg' || id === 'denoise') ? parseFloat(el.value) : parseInt(el.value); }
            });

            // 【核心变化】不再处理 new_upload
            // 检查是否需要图像输入但缺少父节点
            if ((moduleId === 'ImageGenerateImage_Basic' || moduleId === 'ImageGenerateVideo' || moduleId === 'PartialRepainting' || moduleId === 'ImageMerging'||
                moduleId ==='ImageGenerateImage_Canny'||moduleId ==='CameraControl'||moduleId ==='ImageCanny'||moduleId ==='ImageHDRestoration'||
                moduleId ==='PartialRepainting'||moduleId ==='Put_It_Here'||moduleId ==='RemoveBackground') && parentIds.length === 0) {
                    alert('此模块需要输入图像/视频，请先选择一个包含媒体的父节点。');
                    throw new Error('缺少父节点提供输入媒体');
            }
                // 【待扩展】Mask 和 Merging 需要特定的父节点数量检查
                if (moduleId === 'ImageMerging' && parentIds.length !== 2) {
                    alert('图像合并模块需要选择两个父节点。');
                    throw new Error('图像合并需要两个父节点');
                }
                if (moduleId === 'PartialRepainting' && parentIds.length !== 1) {
                    alert('局部重绘模块需要选择一个父节点。');
                    throw new Error('局部重绘需要一个父节点');
                }
                // Mask 文件名需要前端在 parameters 中添加，例如 parameters.mask_filename = ...

            const payload = { tree_id: 1, parent_ids: parentIds, module_id: moduleId, parameters: parameters };
            const response = await fetch(DB_API_POST_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) { const errText = await response.text(); throw new Error(`生成失败: ${errText}`); }

            const updatedTree = await response.json();
            processAndRenderTree(updatedTree, '生成完成！新节点已添加到历史树。'); // 使用新函数处理

        } catch (error) {
            console.error(error);
            // 只对非用户操作错误进行 alert
            if (!['缺少父节点', '需要两个父节点', '需要一个父节点'].some(msg => error.message.includes(msg))) {
                alert(error.message);
            }
            statusEl.textContent = '生成失败，请检查参数或父节点选择。';
        } finally {
            generateBtn.disabled = false;
            buttonText.textContent = '基于父节点生成';
            buttonLoader.classList.add('hidden');
            imageUpload.disabled = false;
            // --- 【新增】生成后取消所有选择 ---             
            selectedParentIds = []; // 1. 清空数组             
            d3.selectAll('.node-card').classed('selected', false); // 2. 移除所有高亮             
            updateSelectedNodeInput(); // 3. 更新文本框
            // --- 结束 【新增】 ---
        }
    }

 // --- 【新增】处理树数据并渲染的辅助函数 ---
    function processAndRenderTree(treeData, statusMessage = '') {
            if (treeData && treeData.nodes) {
            allNodes = treeData.nodes;
            const root = allNodes.find(n => n.parent_id === null);
            rootNodeId = root ? root.node_id : null;

            // --- 构建 D3 需要的数据结构 (与 loadAndRender 中相同) ---
            const nodeMap = {};
            allNodes.forEach(n => {
                const parsedAssets = parseAssetsField(n.assets);
                const firstMedia = firstMediaFromAssets(parsedAssets);
                const media = firstMedia ? { rawPath: firstMedia.path, url: makeFullUrl(firstMedia.path), type: firstMedia.type } : null;
                const firstParentId = Array.isArray(n.parent_id) ? n.parent_id[0] : n.parent_id;
                nodeMap[n.node_id] = { id: n.node_id, parent_id: firstParentId, module_id: n.module_id, created_at: n.created_at, status: n.status, media: media };
                // nodeMap[n.node_id] = { id: n.node_id, parent_id: n.parent_id, module_id: n.module_id, created_at: n.created_at, status: n.status, media: media };
            });
            const fakeRoot = { id: '__ROOT__', module_id: 'ROOT', children: [] };
            Object.values(nodeMap).forEach(n => n.children = []);
            Object.values(nodeMap).forEach(n => {
                if (n.parent_id && nodeMap[n.parent_id]) { nodeMap[n.parent_id].children.push(n); }
                else if (!n.parent_id) { fakeRoot.children.push(n); }
            });

            renderTree(fakeRoot); // 调用 D3 渲染
            showStatus(statusMessage || '点击节点可设为父节点，点击缩略图可预览。');
        } else {
                console.error("接收到的树数据无效:", treeData);
                showStatus("错误：无法处理或渲染树数据。");
        }
    }
    
        // 【新增】查找最新上传节点的辅助函数
    function findLatestUploadNode(nodes) {
        if (!nodes || nodes.length === 0) return null;
        const uploadNodes = nodes.filter(n => n.module_id === 'Upload');
        if (uploadNodes.length === 0) return null;
        return uploadNodes.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];
    }


    async function loadAndRender() {
        // ... 此函数完全不变 ...
        try {
            showStatus('正在从数据库加载作品...');
            const res = await fetch(DB_API_GET_URL);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const treeData = await res.json();
            if (!treeData.nodes || treeData.nodes.length === 0) {
                showStatus('数据库中没有找到任何节点。请在右侧开始您的第一次生成。');
                allNodes = []; wrapper.innerHTML = ''; return;
            }
            allNodes = treeData.nodes;
            const root = allNodes.find(n => n.parent_id === null);
            rootNodeId = root ? root.node_id : null;

            const nodeMap = {};
            allNodes.forEach(n => {
                const parsedAssets = parseAssetsField(n.assets);
                const firstMedia = firstMediaFromAssets(parsedAssets);
                const media = firstMedia ? { rawPath: firstMedia.path, url: makeFullUrl(firstMedia.path), type: firstMedia.type } : null;
                // nodeMap[n.node_id] = { id: n.node_id, parent_id: n.parent_id, module_id: n.module_id, created_at: n.created_at, status: n.status, media: media };
                const firstParentId = Array.isArray(n.parent_id) ? n.parent_id[0] : n.parent_id;
                nodeMap[n.node_id] = { id: n.node_id, parent_id: firstParentId, module_id: n.module_id, created_at: n.created_at, status: n.status, media: media };
            });

            const fakeRoot = { id: '__ROOT__', module_id: 'ROOT', children: [] };
            Object.values(nodeMap).forEach(n => n.children = []);
            Object.values(nodeMap).forEach(n => {
                if (n.parent_id && nodeMap[n.parent_id]) {
                    nodeMap[n.parent_id].children.push(n);
                } else if (!n.parent_id) {
                    fakeRoot.children.push(n);
                }
            });
            renderTree(fakeRoot);
            showStatus('点击节点可设为父节点，点击缩略图可预览。');
        } catch (err) {
            console.error(err);
            showStatus('加载失败: ' + err.message);
        }
    }

    function renderTree(rootData) {
        wrapper.innerHTML = '';
        const width = wrapper.clientWidth || 1200;
        const height = wrapper.clientHeight || 600;

        const svg = d3.select('#chart').append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', `0 0 ${width} ${height}`).attr('preserveAspectRatio', 'xMidYMid meet');
        const g = svg.append('g').attr('transform', `translate(80, ${height/2})`);
        const zoom = d3.zoom().scaleExtent([0.1, 2.5]).on('zoom', (event) => g.attr('transform', event.transform));
        svg.call(zoom);
        // --- 【新增】点击SVG空白处，取消所有选择 ---
        svg.on('click', (event) => {
            // event.stopPropagation(); // 可选：如果SVG外层还有监听器，则需要
            selectedParentIds = []; // 1. 清空数组
            d3.selectAll('.node-card').classed('selected', false); // 2. 移除所有高亮
            updateSelectedNodeInput(); // 3. 更新文本框
        });
        // --- 结束 【新增】 ---

        const root = d3.hierarchy(rootData, d => d.children);
        const treeLayout = d3.tree().nodeSize([180, 220]);
        treeLayout(root);

        g.selectAll('.link').data(root.links().filter(d => d.source.data.id !== '__ROOT__')).enter().append('path').attr('class', 'link').attr('d', d => `M${d.source.y+140},${d.source.x} C${d.source.y+180},${d.source.x} ${d.target.y-40},${d.target.x} ${d.target.y},${d.target.x}`).attr('stroke', '#9ca3af').attr('fill', 'none');
        const node = g.selectAll('.node').data(root.descendants().filter(d => d.data.id !== '__ROOT__')).enter().append('g').attr('class', 'node').attr('transform', d => `translate(${d.y}, ${d.x - 70})`);

        node.each(function(d) {
            const fo = d3.select(this).append('foreignObject').attr('width', 140).attr('height', 140).style('overflow', 'visible');
            //const div = fo.append('xhtml:div').attr('class', 'node-card').style('cursor', 'pointer');
            // const div = fo.append('xhtml:div').attr('class', 'node-card group').style('cursor', 'pointer');
            // div.on('click', function(event) {
            //     event.stopPropagation();
            //     selectedParentNodeId = d.data.id;
            //     selectedNodeInput.value = `已选择: ${d.data.id.substring(0, 8)}...`;
            //     d3.selectAll('.node-card').classed('selected', false);
            //     d3.select(this).classed('selected', true);
            // });

            const div = fo.append('xhtml:div').attr('class', 'node-card group').style('cursor', 'pointer');

            //【新增】让节点在重绘时保持选中状态
            div.classed('selected', selectedParentIds.includes(d.data.id));
            div.on('click', function(event) {
                event.stopPropagation();
                const nodeId = d.data.id;
                const card = d3.select(this);
                // 检查是否已在数组中
                const index = selectedParentIds.indexOf(nodeId);
                if (index > -1) {
                    // 已存在，取消选择
                    selectedParentIds.splice(index, 1);
                    card.classed('selected', false);
                } else {
                    // 不存在，加入选择
                    selectedParentIds.push(nodeId);
                    card.classed('selected', true);
                }
                // 更新顶部的文本框
                updateSelectedNodeInput();
            });
            
            ////////////////新加删除符号/////////////////
            //if (d.data.parent_id !== null && d.data.module_id !== 'ROOT') {
            if (d.data.module_id !== 'Init' && d.data.module_id !== 'ROOT') {
                div.append('xhtml:button')
                    .attr('class', 'absolute top-1 left-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs leading-5 text-center font-bold opacity-0 group-hover:opacity-70 hover:opacity-100 z-10 transition-opacity duration-150')
                    .style('font-size', '11px') // 让 'X' 更美观
                    .text('X')
                    .on('click', (event) => {
                        event.stopPropagation(); // 阻止触发节点的选择事件
                        handleDeleteNode(d.data.id, d.data.module_id);
                    });
            }
            // --- 结束 【新增】删除按钮 ---

            if (d.data.media && d.data.media.rawPath) {
                const rawPath = d.data.media.rawPath;
                const mediaUrl = d.data.media.url;
                const isVideo = (typeof rawPath === 'string') && (rawPath.includes('.mp4') || rawPath.includes('subfolder=video'));
                const canAddToStitch = true; 
                if (isVideo) {
                    /////////视频加"+"按钮/////////////
                    if (canAddToStitch) {
                        div.append('xhtml:button')
                        .attr('class', 'absolute bottom-1 right-1 bg-blue-500 text-white rounded-full w-5 h-5 text-xs leading-5 text-center font-bold opacity-0 group-hover:opacity-80 hover:opacity-100 transition-opacity duration-150')
                        .text('+')
                        .on('click', (event) => {
                            event.stopPropagation(); // 阻止触发节点的选择事件
                            addClipToStitch(d.data,'video'); // 调用添加函数
                        });
                    }
                    ////////////////////////////////////
                    const videoEl = div.append('xhtml:video').attr('class', 'thumb').attr('muted', true).attr('playsinline', true).attr('preload', 'metadata').node();
                    videoEl.autoplay = true; videoEl.loop = true; videoEl.muted = true; videoEl.playsInline = true; videoEl.src = mediaUrl;
                    videoEl.addEventListener('click', (ev) => { ev.stopPropagation(); openPreview(mediaUrl, 'video'); });
                } else {
                    /////////图片加"+"按钮/////////////
                    if (canAddToStitch) {
                        div.append('xhtml:button')
                        .attr('class', 'absolute bottom-1 right-1 bg-blue-500 text-white rounded-full w-5 h-5 text-xs leading-5 text-center font-bold opacity-0 group-hover:opacity-80 hover:opacity-100 transition-opacity duration-150')
                        .text('+')
                        .on('click', (event) => {
                            event.stopPropagation(); // 阻止触发节点的选择事件
                            addClipToStitch(d.data,'image'); // 调用添加函数
                        });
                    }
                    ////////////////////////////////////
                    const imgEl = div.append('xhtml:img').attr('class', 'thumb').attr('src', mediaUrl).attr('alt', d.data.module_id || 'thumb').node();
                    imgEl.addEventListener('click', (ev) => { ev.stopPropagation(); openPreview(mediaUrl, 'image'); });
                }
            } else {
                div.append('xhtml:div').attr('class', 'thumb').style('display','flex').style('align-items','center').style('justify-content','center').style('font-size','12px').style('color','#6b7280').text('无缩略图');
            }
            div.append('xhtml:div').attr('class', 'node-label').text(d.data.module_id || '(节点)');
            const titleText = (d.data.module_id || '') + (d.data.created_at ? ' · ' + d.data.created_at : '') + (d.data.status ? ' · ' + d.data.status : '');
            this.setAttribute('title', titleText);
        });
    }

    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePreview(); });
    generateBtn.addEventListener('click', handleGenerate);
    imageUpload.addEventListener('change', handleFileUpload);
    stitchButton.addEventListener('click', handleStitchRequest); // 【新增】拼接按钮监听
    loadAndRender();
});
</script>
</body>
</html>